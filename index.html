<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" content="notranslate">

    <title>VGauge demo</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/open-sans-all@0.1.3/css/open-sans.min.css" rel="stylesheet">

    <style>
        html, body {
            font-family: 'Open Sans', sans-serif;
            margin: 0;
            height: 100%
        }

        button {
            white-space: nowrap;
        }

        #demo {
            margin-left: auto;
            margin-right: auto;
        }

        .nineByNine {
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            grid-template-columns: repeat(4, 1fr);
            max-width: 380px;
            box-sizing: border-box;
        }

            .nineByNine .box {
                box-sizing: border-box;
            }

        .gaugeContainer {
            display: block;
            margin-left: auto;
            margin-right: auto;
            max-width: 380px;
        }

        #settingsEditView {
            width: 100%;
            max-width: 512px;
        }

        #settingsEditJson, #settingsViewInitializer {
            font-family: monospace;
            /*overflow: auto;*/
            white-space: pre;
        }

        .modal-content {
            font-family: monospace;
        }
    </style>
</head>

<body>
    <script>
        'strict'
        const theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        document.documentElement.setAttribute('data-bs-theme', theme);
    </script>


    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
            <div class="navbar-text">vgauge demo</div>
            <div class="navbar-item">
                <a class="nav-link" href="https://github.com/A-J-Bauer/VGauge/tree/main"><i class="bi bi-github"></i></a>
            </div>
            <div class="btn-group" role="group" aria-label="dark light theme">
                <button id="darkThemeBtn" type="button" class="btn btn-dark">Dark</button>
                <button id="lightThemeBtn" type="button" class="btn btn-light">Light</button>
            </div>
        </div>
    </nav>

    <div class="container text-center">

        <div class="row row-cols-1 mt-4 mb-4">
            <div class="col">
                <div id="demo">
                    <!--
                    to make the gauge container focusable/selectable:
                    - add tabindex="0" to the container div
                    - for bootstrap add form-control, mb-2 and mt-2 to class
                    -->
                    <div id="gaugeContainer">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="-50 -50 100 100"></svg>
                    </div>
                </div>
            </div>
        </div>

        <div class="row row-cols-1">
            <div class="col d-flex justify-content-center mb-3">
                <div>
                    <input type="checkbox" class="btn-check" id="demoShow4By4" autocomplete="off">
                    <label class="btn btn-primary" style="width:5em" for="demoShow4By4"
                           data-bs-toggle="tooltip" data-bs-title="multiple instances">
                        4x4
                    </label>
                </div>
                <div class="input-group ms-2 me-2" style="max-width:7em">
                    <span class="input-group-text">fps</span>
                    <input id="gaugeFpsInp" type="text" class="form-control text-center" readonly>
                </div>
                <div>
                    <input type="checkbox" class="btn-check" id="gaugeStartStopToggle" autocomplete="off">
                    <label class="btn btn-success" style="width:5em" for="gaugeStartStopToggle"
                           data-bs-toggle="tooltip" data-bs-title="toggle measurement">
                        Start
                    </label>
                </div>
            </div>
        </div>

        <div class="row row-cols-1">
            <div class="col d-flex justify-content-center">
                <div class="d-flex">
                    <button id="gaugeRecreateBtn" type="button" class="btn btn-primary me-2"
                            data-bs-toggle="tooltip" data-bs-title="recreate from JSON">
                        <i class="bi bi-arrow-clockwise"></i> recreate
                    </button>
                    <div>
                        <input type="checkbox" class="btn-check" id="helperGridToggle" autocomplete="off">
                        <label class="btn btn-primary me-2" for="helperGridToggle"
                               data-bs-toggle="tooltip" data-bs-title="toggle grid">
                            <i class="bi bi-grid-3x3"></i>
                        </label>
                    </div>
                    <div>
                        <input type="checkbox" class="btn-check" id="iconToggle" autocomplete="off">
                        <label class="btn btn-primary me-2" for="iconToggle"
                               data-bs-toggle="tooltip" data-bs-title="toggle icon">
                            <i class="bi bi-fire"></i>
                        </label>
                    </div>
                    <button id="targetValueDecreaseBtn" type="button" class="btn btn-primary me-2"
                            data-bs-toggle="tooltip" data-bs-title="decrease target value">
                        <i class="bi bi-chevron-down"></i>
                    </button>
                    <button id="targetValueIncreaseBtn" type="button" class="btn btn-primary"
                            data-bs-toggle="tooltip" data-bs-title="increase target value">
                        <i class="bi bi-chevron-up"></i>
                    </button>
                </div>
            </div>
        </div>

        <div class="row row-cols-1 mt-4 mb-2">
            <div class="col d-flex justify-content-center">
                <div id="settingsEditView">
                    <ul class="nav nav-pills m-3" id="myTab" role="tablist">
                        <li class="nav-item" role="presentation"
                            data-bs-toggle="tooltip" data-bs-title="edit JSON">
                            <button class="nav-link active"
                                    id="editJson"
                                    data-bs-toggle="tab"
                                    data-bs-target="#editJson-pane"
                                    type="button"
                                    role="tab"
                                    aria-controls="editJson-pane"
                                    aria-selected="true">
                                <i class="bi bi-filetype-json"></i> <i class="bi bi-pencil"></i>
                            </button>
                        </li>
                        <li class="nav-item" role="presentation"
                            data-bs-toggle="tooltip" data-bs-title="view settings initializer">
                            <button class="nav-link"
                                    id="viewInitializer"
                                    data-bs-toggle="tab"
                                    data-bs-target="#viewInitializer-pane"
                                    type="button"
                                    role="tab"
                                    aria-controls="viewInitializer-pane"
                                    aria-selected="false">
                                <i class="bi bi-filetype-js"></i>
                            </button>
                        </li>
                    </ul>
                    <div class="tab-content" id="myTabContent">
                        <div class="tab-pane mb-2 mt-2 fade show active" id="editJson-pane" role="tabpanel" aria-labelledby="editJson" tabindex="0">
                            <textarea class="form-control" id="settingsEditJson" rows="16" spellcheck="false"></textarea>
                        </div>
                        <div class="tab-pane mb-2 mt-2 fade" id="viewInitializer-pane" role="tabpanel" aria-labelledby="viewInitializer" tabindex="0">
                            <textarea class="form-control" id="settingsViewInitializer" readonly rows="16" spellcheck="false"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="errorModal" class="modal fade" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="errorModalLabel">VGauge</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    ...
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        'strict'

        /*
         * VGauge
         * copyright (c) 2024 A.J.Bauer
         * licensed under the MIT License.
         * see LICENSE.txt for full license text.
         */

        class VGauge {
            static isNonEmptyString(s) {
                return typeof s === 'string' && s !== '';
            }

            static isInteger(n) {
                return Number.isInteger(parseInt(n));
            }

            static isBoolean(b) {
                return typeof b === 'boolean';
            }

            static isNonEmptyArray(a) {
                return Array.isArray(a) && a.length > 0;
            }

            static hexRgbForColor(color) {
                let hr, hg, hb;
                if (color.startsWith('#')) {
                    if (color.length === 4) {
                        hr = color.charAt(1);
                        hg = color.charAt(2);
                        hb = color.charAt(3);
                        return '#' + hr + hr + hg + hg + hb + hb;
                    } else {
                        return color.substring(0, 8);
                    }
                } else if (color.startsWith('rgb')) {
                    const allInts = color.match(/\d+/g);
                    if (allInts.length > 2) {
                        return '#' + parseInt(allInts[0]).toString(16) + parseInt(allInts[1]).toString(16) + parseInt(allInts[2]).toString(16);
                    } else {
                        console.error(this.constructor.name + ': unexpected value for rgb color');
                        return '#ff0000';
                    }
                } else if (color.length > 0) {
                    console.error(this.constructor.name + ': unsupported color');
                }
            }

            static _getObjectInitializer(obj, n, t, c) {
                t = (t === undefined ? 0 : t);
                c = (c === undefined ? false : c);

                let str = ' '.repeat(t) + '{\r\n';
                t += n;

                const last = Object.keys(obj).slice(-1)[0];
                for (const [key, value] of Object.entries(obj)) {
                    if (obj.hasOwnProperty(key)) {
                        if (Array.isArray(value)) {
                            str += ' '.repeat(t) + key + ': [\r\n';
                            for (var i = 0; i < value.length; i++) {
                                str += VGauge._getObjectInitializer(value[i], n, t + n, (i !== value.length - 1)) + '\r\n';
                            }
                            str += ' '.repeat(t) + ']';
                        }
                        else if (typeof value === 'object') {
                            str += ' '.repeat(t) + key + ':\r\n' + VGauge._getObjectInitializer(value, n, t, key !== last) + (key !== last ? '\r\n' : '');
                        }
                        else if (typeof value === 'string') {
                            str += ' '.repeat(t) + key + ': \'' + value + '\'' + (key === last ? '' : ',\r\n');
                        }
                        else {
                            str += ' '.repeat(t) + key + ': ' + value + (key === last ? '' : ',\r\n');
                        }
                    }
                }

                str += '\r\n' + ' '.repeat(t - n) + '}' + (c ? ',' : '');

                return str;
            }

            static getObjectInitializer(obj, n) {
                n = (n === undefined ? 1 : n);
                return VGauge._getObjectInitializer(obj, n);
            }

            constructor(containerId, settings) {
                this._initialized = false;
                this._id = containerId;
                this._settings = settings;

                this._value = 0.0;
                this._targetValue = 0.0;

                this._rootStyles = null;
                this._bodyStyles = null;
                this._containerStyles = null;
                this._container = null;

                this._svg = null;
                this._svgElems = {
                    background: null,
                    helperGrid: null,
                    labels: null,
                    name: null,
                    unit: null,
                    value: null,
                    cluster: null,
                    ticks: null,
                    icons: null,
                    valueSector: null,
                    targetValue: null,
                    targetValueIndicator: null
                };

                this._tickLabelsMinusSignWidth = 0;
                this._tickLabelsHeight = 0;
                this._targetValueLabelMinusSignWidth = 0;
                this._targetValueLabelLabelsHeight = 0;

                this._fontFamily = '';
                this._currentColor = null;

                this._width = 0;
                this._height = 0;

                this.recreate();
            }

            recreate() {
                this._initialized = false;

                if (this._settings === undefined || this._settings === null || typeof this._settings !== 'object') {
                    console.error(this.constructor.name + ': settings needed');
                }

                this._container = document.querySelector('#' + this._id);

                if (this._container) {

                    this._container.innerHTML = '';

                    this._width = this._height = this._container.clientWidth;

                    this._rootStyles = getComputedStyle(document.documentElement);
                    this._bodyStyles = window.getComputedStyle(document.body);
                    this._containerStyles = window.getComputedStyle(this._container);

                    this._fontFamily = VGauge.isNonEmptyString(this._settings.tweek.fontFamily)
                        ? this._settings.tweek.fontFamily : this._bodyStyles.fontFamily.replace(/"/g, '');

                    this._currentColor = this._containerStyles.color;

                    this._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    this._svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    this._svg.setAttribute('viewBox', '-50 -50 100 100');
                    //this._svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

                    this._svgElems.background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    this._svgElems.background.setAttribute('x', '-50');
                    this._svgElems.background.setAttribute('y', '-50');
                    this._svgElems.background.setAttribute('width', '100');
                    this._svgElems.background.setAttribute('height', '100');
                    this._svgElems.background.setAttribute('stroke', 'none');
                    this._svgElems.background.setAttribute('fill', 'none');
                    this._svg.append(this._svgElems.background);

                    if (VGauge.isBoolean(this._settings.useHelperGrid) && this._settings.useHelperGrid) {
                        this._svgElems.helperGrid = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        this._svgElems.helperGrid.setAttribute('opacity', '0');
                        this._svgElems.helperGrid.setAttribute('stroke', 'currentColor');
                        this._svgElems.helperGrid.setAttribute('stroke-width', '0.05');
                        this._svg.append(this._svgElems.helperGrid);
                    }

                    this._svgElems.labels = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    this._svgElems.labels.setAttribute('font-family', this._fontFamily);

                    this._svgElems.name = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    this._svgElems.name.setAttribute('text-anchor', 'middle');
                    this._svgElems.labels.append(this._svgElems.name);

                    this._svgElems.unit = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    this._svgElems.unit.setAttribute('text-anchor', 'start');
                    this._svgElems.labels.append(this._svgElems.unit);

                    this._svgElems.value = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    this._svgElems.value.setAttribute('text-anchor', 'end');
                    this._svgElems.value.innerHTML = this._value.toFixed(this._settings.tweek.value.decimals);
                    this._svgElems.labels.append(this._svgElems.value);

                    this._svg.append(this._svgElems.labels);

                    if (this._settings.cluster) {
                        this._svgElems.cluster = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        if (VGauge.isNonEmptyArray(this._settings.cluster.sectors)) {
                            for (let i = 0; i < this._settings.cluster.sectors.length; i++) {
                                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                path.setAttribute('d', 'M 0,0');
                                this._svgElems.cluster.append(path);
                            }
                        }
                        this._svg.append(this._svgElems.cluster);
                    }

                    if (this._settings.cluster.useTickLabels) {
                        this._svgElems.ticks = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        this._svg.append(this._svgElems.ticks);
                    }

                    if (VGauge.isNonEmptyArray(this._settings.icons)) {
                        this._svgElems.icons = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        for (var i = 0; i < this._settings.icons.length; i++) {
                            try {
                                const iconSettings = this._settings.icons[i];
                                const icon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                const transform = 'translate(' + iconSettings.x + ',' + iconSettings.y + ') '
                                    + 'scale(' + iconSettings.scale + ',' + iconSettings.scale + ')';
                                icon.setAttribute('transform', transform);
                                icon.setAttribute('rid', iconSettings.id);
                                const d = (new DOMParser).parseFromString(iconSettings.path, "image/svg+xml").querySelector('[d]').getAttribute('d');
                                icon.setAttribute('d', d);
                                icon.setAttribute('opacity', iconSettings.opacity);
                                if (VGauge.isNonEmptyString(iconSettings.fill)) {
                                    icon.setAttribute('fill', iconSettings.fill);
                                } else {
                                    icon.setAttribute('fill', 'currentColor');
                                }
                                this._svgElems.icons.append(icon);

                            } catch (e) {
                                console.error(this.constructor.name + ': icons error : ' + error);
                            }
                        }
                        this._svg.append(this._svgElems.icons);
                    }

                    this._svgElems.valueSector = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    this._svg.append(this._svgElems.valueSector);

                    if (this._settings.targetValue) {
                        this._svgElems.targetValueIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        this._svg.append(this._svgElems.targetValueIndicator);

                        this._svgElems.targetValueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        this._svg.append(this._svgElems.targetValueLabel);
                    }

                    this._container.prepend(this._svg);

                    this._svg.setAttribute('style', 'user-select:none');

                    if (VGauge.isNonEmptyString(this._settings.tweek.backgroundColor)) {
                        this._svgElems.background.setAttribute('fill', VGauge.hexRgbForColor(this._settings.tweek.backgroundColor));
                    } else {
                        this._svgElems.background.setAttribute('fill', 'none');
                    }

                    if (VGauge.isBoolean(this._settings.useHelperGrid) && this._settings.useHelperGrid) {
                        for (let i = -50; i <= 50; i += 10) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', i);
                            line.setAttribute('x2', i);
                            line.setAttribute('y1', -50);
                            line.setAttribute('y2', 50);
                            if (i === 0) {
                                line.setAttribute('stroke-width', '0.1');
                            }
                            this._svgElems.helperGrid.append(line);
                        }

                        for (let i = -50; i <= 50; i += 10) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', -50);
                            line.setAttribute('x2', 50);
                            line.setAttribute('y1', i);
                            line.setAttribute('y2', i);
                            if (i === 0) {
                                line.setAttribute('stroke-width', '0.1');
                            }
                            this._svgElems.helperGrid.append(line);
                        }
                    }

                    this._svgElems.name.setAttribute('x', this._settings.tweek.name.x);
                    this._svgElems.name.setAttribute('y', this._settings.tweek.name.y);
                    if (VGauge.isNonEmptyString(this._settings.tweek.name.fill)) {
                        this._svgElems.name.setAttribute('fill', this._settings.tweek.name.fill);
                    } else {
                        this._svgElems.name.setAttribute('fill', 'currentColor');
                    }
                    this._svgElems.name.setAttribute('font-size', this._settings.tweek.name.fontSize);
                    this._svgElems.name.innerHTML = this._settings.name;

                    this._svgElems.unit.setAttribute('x', this._settings.tweek.unit.x);
                    this._svgElems.unit.setAttribute('y', this._settings.tweek.unit.y);
                    if (VGauge.isNonEmptyString(this._settings.tweek.unit.fill)) {
                        this._svgElems.unit.setAttribute('fill', this._settings.tweek.unit.fill);
                    } else {
                        this._svgElems.unit.setAttribute('fill', 'currentColor');
                    }
                    this._svgElems.unit.setAttribute('font-size', this._settings.tweek.unit.fontSize);
                    this._svgElems.unit.innerHTML = this._settings.unit;

                    this._svgElems.value.setAttribute('x', this._settings.tweek.value.x);
                    this._svgElems.value.setAttribute('y', this._settings.tweek.value.y);
                    this._svgElems.value.setAttribute('fill', this._settings.tweek.value.fill);
                    if (VGauge.isNonEmptyString(this._settings.tweek.value.fill)) {
                        this._svgElems.value.setAttribute('fill', this._settings.tweek.value.fill);
                    } else {
                        this._svgElems.value.setAttribute('fill', 'currentColor');
                    }
                    this._svgElems.value.setAttribute('font-size', this._settings.tweek.value.fontSize);

                    if (this._settings.cluster && this._settings.cluster.sectors
                        && VGauge.isNonEmptyArray(this._settings.cluster.sectors)) {

                        const point1 = { x: 0.0, y: 0.0 };
                        const point2 = { x: 0.0, y: 0.0 };
                        const prevPoint1 = { x: 0.0, y: 0.0 };
                        const prevPoint2 = { x: 0.0, y: 0.0 };

                        let prevAngle = this._settings.startAngle * Math.PI / 180.0;
                        let prevSweepTo = this._settings.min;
                        let angle = 0.0;

                        let addSvgTickLabel = (value, angle) => {
                            const textPoint = { x: 0, y: 0 };
                            const rotate = angle < Math.PI ? angle + 1.5 * Math.PI : angle + 0.5 * Math.PI;

                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.innerHTML = value;

                            textPoint.x = this._settings.tweek.ticks.radius * Math.cos(angle);
                            textPoint.y = this._settings.tweek.ticks.radius * Math.sin(angle);

                            const tr1 = 'translate(' + textPoint.x + ',' + textPoint.y + ')';
                            const rot = 'rotate(' + (rotate * 180.0 / Math.PI) + ')';
                            const tr2 = 'translate(' + (value < 0 ? -this._tickLabelsMinusSignWidth / 2.0 : 0) + ',' + (this._tickLabelsHeight / 2.0) + ')';
                            const transform = tr1 + ' ' + rot + ' ' + tr2;

                            label.setAttribute('transform', transform);

                            this._svgElems.ticks.append(label);
                        }

                        if (this._settings.cluster.useTickLabels) {
                            const measureCanvas = new OffscreenCanvas(1, 1);
                            const measureCtx = measureCanvas.getContext('2d');

                            measureCtx.textAlign = 'center';
                            measureCtx.textBaseline = 'alphabetic';

                            measureCtx.font = this._settings.tweek.ticks.fontSize + ' ' + this._fontFamily;
                            this._tickLabelsMinusSignWidth = measureCtx.measureText('-').width;
                            this._tickLabelsHeight = measureCtx.measureText('0123456789').actualBoundingBoxAscent;

                            if (this._settings.targetValue) {
                                measureCtx.font = this._settings.targetValue.label.fontSize + ' ' + this._fontFamily;
                                this._targetValueLabelMinusSignWidth = measureCtx.measureText('-').width;
                                this._targetValueLabelHeight = measureCtx.measureText('0123456789').actualBoundingBoxAscent;
                            }

                            this._svgElems.ticks.setAttribute('text-anchor', 'middle');
                            this._svgElems.ticks.setAttribute('dominant-baseline', 'alphabetic');
                            this._svgElems.ticks.setAttribute('font-size', this._settings.tweek.ticks.fontSize);
                            this._svgElems.ticks.setAttribute('font-family', this._fontFamily);
                            this._svgElems.ticks.setAttribute('opacity', this._settings.tweek.ticks.opacity)
                            if (VGauge.isNonEmptyString(this._settings.tweek.ticks.fill)) {
                                this._svgElems.ticks.setAttribute('fill', this._settings.tweek.ticks.fill);
                            } else {
                                this._svgElems.ticks.setAttribute('fill', 'currentColor');
                            }
                        }

                        for (let i = 0; i < this._settings.cluster.sectors.length; i++) {
                            const sector = this._settings.cluster.sectors[i];

                            prevPoint1.x = this._settings.cluster.innerRadius * Math.cos(prevAngle);
                            prevPoint1.y = this._settings.cluster.innerRadius * Math.sin(prevAngle);
                            prevPoint2.x = this._settings.cluster.outerRadius * Math.cos(prevAngle);
                            prevPoint2.y = this._settings.cluster.outerRadius * Math.sin(prevAngle);

                            angle = prevAngle + (sector.sweepTo - prevSweepTo)
                                * this._settings.sweepAngle
                                / (this._settings.max - this._settings.min)
                                * Math.PI / 180.0;

                            point1.x = this._settings.cluster.innerRadius * Math.cos(angle);
                            point1.y = this._settings.cluster.innerRadius * Math.sin(angle);
                            point2.x = this._settings.cluster.outerRadius * Math.cos(angle);
                            point2.y = this._settings.cluster.outerRadius * Math.sin(angle);

                            const d = 'M ' + prevPoint1.x + ',' + prevPoint1.y + ' '
                                + 'A ' + this._settings.cluster.innerRadius + ' ' + this._settings.cluster.innerRadius + ' ' + (angle - prevAngle) * 180.0 / Math.PI + ' '
                                + (angle - prevAngle > Math.PI ? '1' : '0') + ' 1 ' + point1.x + ' ' + point1.y + ' '
                                + 'L ' + point2.x + ',' + point2.y + ' '
                                + 'A ' + this._settings.cluster.outerRadius + ' ' + this._settings.cluster.outerRadius + ' ' + (angle - prevAngle) * 180.0 / Math.PI + ' '
                                + (angle - prevAngle > Math.PI ? '1' : '0') + ' 0 ' + prevPoint2.x + ' ' + prevPoint2.y + ' '
                                + 'L ' + prevPoint1.x + ',' + prevPoint1.y + ' Z';

                            const path = Array.from(this._svgElems.cluster.querySelectorAll('path'))[i];

                            path.setAttribute('d', d);
                            path.setAttribute('opacity', sector.opacity);

                            if (VGauge.isNonEmptyString(sector.fill)) {
                                path.setAttribute('fill', VGauge.hexRgbForColor(sector.fill));
                            }
                            else {
                                path.setAttribute('fill', VGauge.hexRgbForColor(this._currentColor));
                            }

                            if (this._settings.cluster.useTickLabels) {
                                if (i === 0) {
                                    addSvgTickLabel(this._settings.min, this._settings.startAngle * Math.PI / 180.0);
                                }
                                addSvgTickLabel(sector.sweepTo, angle);
                            }

                            prevSweepTo = sector.sweepTo;
                            prevAngle = angle;
                        }
                    }

                    if (this._settings.targetValue) {
                        if (VGauge.isNonEmptyString(this._settings.targetValue.indicator.path)) {
                            const d = (new DOMParser).parseFromString(this._settings.targetValue.indicator.path, "image/svg+xml").querySelector('[d]').getAttribute('d');
                            this._svgElems.targetValueIndicator.setAttribute('d', d);
                        }

                        if (VGauge.isNonEmptyString(this._settings.targetValue.indicator.fill)) {
                            this._svgElems.targetValueIndicator.setAttribute('fill', this._settings.targetValue.indicator.fill);
                        } else {
                            this._svgElems.targetValueIndicator.setAttribute('fill', 'currentColor');
                        }

                        if (VGauge.isNonEmptyString(this._settings.targetValue.label.fontSize)) {
                            this._svgElems.targetValueLabel.setAttribute('font-size', this._settings.targetValue.label.fontSize);
                        }

                        if (VGauge.isNonEmptyString(this._settings.targetValue.label.fill)) {
                            this._svgElems.targetValueLabel.setAttribute('fill', this._settings.targetValue.label.fill);
                        } else {
                            this._svgElems.targetValueLabel.setAttribute('fill', 'currentColor');
                        }

                        this._svgElems.targetValueLabel.setAttribute('text-anchor', 'middle');
                        this._svgElems.targetValueLabel.setAttribute('dominant-baseline', 'alphabetic');
                    }

                    if (this._settings.targetValue) {
                        this.targetValue = this._settings.targetValue.min;
                    }

                    this._initialized = true;
                    this.refresh();
                }
                else {
                    console.error(this.constructor.name + ': could not find container for id ' + this._id);
                }
            }

            _update() {
                const prevAngle = this._settings.startAngle * Math.PI / 180.0;
                let angle = this._settings.startAngle * Math.PI / 180.0 + (this._value - this._settings.min)
                    * this._settings.sweepAngle
                    / (this._settings.max - this._settings.min)
                    * Math.PI / 180.0;

                const prevPoint1 = {
                    x: this._settings.indicator.innerRadius * Math.cos(prevAngle),
                    y: this._settings.indicator.innerRadius * Math.sin(prevAngle)
                };
                const prevPoint2 = {
                    x: this._settings.indicator.outerRadius * Math.cos(prevAngle),
                    y: this._settings.indicator.outerRadius * Math.sin(prevAngle)
                };
                const point1 = {
                    x: this._settings.indicator.innerRadius * Math.cos(angle),
                    y: this._settings.indicator.innerRadius * Math.sin(angle)
                };
                const point2 = {
                    x: this._settings.indicator.outerRadius * Math.cos(angle),
                    y: this._settings.indicator.outerRadius * Math.sin(angle)
                };

                this._svgElems.value.innerHTML = this._value.toFixed(this._settings.tweek.value.decimals);

                const d = 'M ' + prevPoint1.x + ',' + prevPoint1.y + ' '
                    + 'A ' + this._settings.indicator.innerRadius + ' ' + this._settings.indicator.innerRadius + ' ' + (angle - prevAngle) * 180.0 / Math.PI + ' '
                    + (angle - prevAngle > Math.PI ? '1' : '0') + ' 1 ' + point1.x + ' ' + point1.y + ' '
                    + 'L ' + point2.x + ',' + point2.y + ' '
                    + 'A ' + this._settings.indicator.outerRadius + ' ' + this._settings.indicator.outerRadius + ' ' + (angle - prevAngle) * 180.0 / Math.PI + ' '
                    + (angle - prevAngle > Math.PI ? '1' : '0') + ' 0 ' + prevPoint2.x + ' ' + prevPoint2.y + ' '
                    + 'L ' + prevPoint1.x + ',' + prevPoint1.y + ' Z';


                if (this._settings.cluster && VGauge.isNonEmptyArray(this._settings.cluster.sectors)) {
                    let sector = this._settings.cluster.sectors.find(x => x.sweepTo >= this._value);
                    if (sector === undefined) {
                        sector = this._settings.cluster.sectors[0];
                    }

                    if (VGauge.isNonEmptyString(sector.fill)) {
                        this._svgElems.valueSector.setAttribute('fill', VGauge.hexRgbForColor(sector.fill));
                    } else {
                        this._svgElems.valueSector.setAttribute('fill', VGauge.hexRgbForColor(this._currentColor));
                    }

                }
                else {
                    this._svgElems.valueSector.setAttribute('fill', VGauge.hexRgbForColor(this._currentColor));
                    this._svgElems.valueSector.setAttribute('opacity', 1);
                }

                this._svgElems.valueSector.setAttribute('d', d);

                if (this._settings.targetValue) {
                    const tipPoint = { x: 0, y: 0 };

                    angle = this._settings.startAngle * Math.PI / 180.0 + (this._targetValue - this._settings.min)
                        * this._settings.sweepAngle
                        / (this._settings.max - this._settings.min)
                        * Math.PI / 180.0;

                    tipPoint.x = this._settings.targetValue.indicator.radius * Math.cos(angle);
                    tipPoint.y = this._settings.targetValue.indicator.radius * Math.sin(angle);
                    let rotate = angle * 180.0 / Math.PI - 90;
                    let transform = 'translate(' + tipPoint.x + ',' + tipPoint.y + ') rotate(' + rotate + ')';
                    this._svgElems.targetValueIndicator.setAttribute('transform', transform);
                    const rotateLabel = angle < Math.PI ? angle + 1.5 * Math.PI : angle + 0.5 * Math.PI;

                    const labelPoint = { x: 0, y: 0 };
                    rotate = angle < Math.PI ? angle + 1.5 * Math.PI : angle + 0.5 * Math.PI;

                    labelPoint.x = this._settings.targetValue.label.radius * Math.cos(angle);
                    labelPoint.y = this._settings.targetValue.label.radius * Math.sin(angle);

                    const tr1 = 'translate(' + labelPoint.x + ',' + labelPoint.y + ')';
                    const rot = 'rotate(' + (rotate * 180.0 / Math.PI) + ')';
                    const tr2 = 'translate(' + (this._targetValue < 0 ? -this._targetValueLabelMinusSignWidth / 2.0 : 0) + ',' + (this._targetValueLabelHeight / 2.0) + ')';
                    transform = tr1 + ' ' + rot + ' ' + tr2;

                    this._svgElems.targetValueLabel.innerHTML = this._targetValue;
                    this._svgElems.targetValueLabel.setAttribute('transform', transform);
                }
            }

            refresh() {
                if (!this._initialized) {
                    return;
                }

                this._currentColor = this._containerStyles.color;
                this._width = this._container.clientWidth;
                this._height = this._container.clientHeight;

                if (this._width > 0 && this._height > 0) {
                    this._update();
                }
            }

            get min() {
                return this._settings.min;
            }

            get max() {
                return this._settings.max;
            }

            get settings() {
                return this._settings;
            }

            set settings(obj) {
                this._settings = obj;
            }

            set value(value) {
                if (this._value !== value) {
                    if (value < this._min) {
                        this._value = this._min;
                    }
                    else if (value > this._max) {
                        this._value = this._max;
                    }
                    else {
                        this._value = parseFloat(value);
                    }

                    if (this._initialized) {
                        this._update();
                    }
                }
            }

            get value() {
                return this._value;
            }

            set targetValue(value) {
                if (this._settings.targetValue) {
                    if (value !== this._targetValue) {
                        if (value < this._settings.targetValue.min) {
                            this._targetValue = parseFloat(this._settings.targetValue.min);
                        }
                        else if (value > this._settings.targetValue.max) {
                            this._targetValue = parseFloat(this._settings.targetValue.max);
                        }
                        else {
                            this._targetValue = parseFloat(value);
                        }

                        this._update();
                    }
                }
            }

            get targetValue() {
                return this._targetValue;
            }



            get gridOpacity() {
                const grid = this._svgElems.helperGrid;
                if (grid) {
                    return parseFloat(grid.getAttribute('opacity'));
                }
                return 0;
            }

            set gridOpacity(o) {
                const grid = this._svgElems.helperGrid;
                if (grid) {
                    grid.setAttribute('opacity', o);
                }
            }

            setIconOpacity(id, opacity) {
                const icon = this._container.querySelector('[rid="' + id + '"]');
                if (icon) {
                    icon.setAttribute('opacity', opacity);
                }
            }

        }
    </script>>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {

            const rootStyles = getComputedStyle(document.documentElement);
            const bootStrapColorYellow = rootStyles.getPropertyValue('--bs-yellow');
            const bootStrapColorBlue = rootStyles.getPropertyValue('--bs-blue');
            const bootStrapColorGreen = rootStyles.getPropertyValue('--bs-green');
            const bootStrapColorRed = rootStyles.getPropertyValue('--bs-red');

            // fire icon
            const bootstrapFireIcon = `<path d="M8 16c3.314 0 6-2 6-5.5 0-1.5-.5-4-2.5-6 .25 1.5-1.25 2-1.25 2C11 4 9 .5 6 0c.357 2 .5 4-2 6-1.25 1-2 2.729-2 4.5C2 14 4.686 16 8 16m0-1c-1.657 0-3-1-3-2.75 0-.75.25-2 1.25-3C6.125 10 7 10.5 7 10.5c-.375-1.25.5-3.25 2-3.5-.179 1-.25 2 1 3 .625.5 1 1.364 1 2.25C11 14 9.657 15 8 15"/>`

            const settings = {
                name: 'Room 1',
                unit: '°C',
                min: -20,
                max: 50,
                startAngle: 90,
                sweepAngle: 260,
                useHelperGrid: true,
                cluster: {
                    innerRadius: 30,
                    outerRadius: 40,
                    useTickLabels: true,
                    sectors: [
                        { fill: bootStrapColorYellow, opacity: 0.1, sweepTo: -5 },
                        { fill: bootStrapColorBlue, opacity: 0.1, sweepTo: 20 },
                        { fill: bootStrapColorGreen, opacity: 0.1, sweepTo: 30 },
                        { fill: bootStrapColorRed, opacity: 0.1, sweepTo: 50 }
                    ]
                },
                indicator: {
                    innerRadius: 32,
                    outerRadius: 40
                },
                targetValue: {
                    min: 10,
                    max: 40,
                    indicator: {
                        radius: 35,
                        path: '<path d="M 0,0 L -4,6 L 4,6 Z"></path>',
                        fill: ''
                    },
                    label: {
                        radius: 44.5,
                        fontSize: '6px',
                        fill: ''
                    }
                },
                tweek: {
                    fontFamily: '',
                    backgroundColor: '',
                    name: { x: 0, y: -10, fill: '', fontSize: '7px' },
                    unit: { x: 2, y: 39, fill: '', fontSize: '11px' },
                    value: { x: 40, y: 20, fill: '', fontSize: '1rem', decimals: 1 },
                    ticks: { radius: 44, fontSize: '8px', fill: '#7f7f7f', opacity: 0.1 },
                },
                icons: [{ id: 1, x: 34, y: -45, scale: 1, fill: '', opacity: 1.0, path: bootstrapFireIcon }]
            };




            const gaugeStartStopToggle = document.querySelector('#gaugeStartStopToggle');
            const gaugeRecreateBtn = document.querySelector('#gaugeRecreateBtn');
            const settingsEditJson = document.querySelector('#settingsEditJson');
            const settingsViewInitializer = document.querySelector('#settingsViewInitializer');
            const errorModal = new bootstrap.Modal('#errorModal', { keyboard: true });
            const gaugeFpsInp = document.querySelector('#gaugeFpsInp');
            const helperGridToggle = document.querySelector('#helperGridToggle');
            const iconToggle = document.querySelector('#iconToggle');
            const targetValueDecreaseBtn = document.querySelector('#targetValueDecreaseBtn');
            const targetValueIncreaseBtn = document.querySelector('#targetValueIncreaseBtn');
            const demoShow4By4 = document.querySelector('#demoShow4By4');

            const demo = document.querySelector('#demo');
            const gaugeContainerClone = document.querySelector('#gaugeContainer').cloneNode(true);

            const rows = 4;
            const cols = 4;
            const gauges = [];
            const gaugeContainers = [];

            demo.innerHTML = '';
            for (var i = 0; i < rows * cols; i++) {
                const box = document.createElement('div');
                box.classList.add('box');
                const gaugeContainer = gaugeContainerClone.cloneNode(true);
                gaugeContainer.setAttribute('id', 'gaugeContainer' + i);
                gaugeContainer.classList.add('gaugeContainer');
                box.append(gaugeContainer);
                demo.append(box);

                if (i > 0) {
                    gaugeContainer.style.display = 'none';
                }

                gauges[i] = new VGauge('gaugeContainer' + i, settings);
                gaugeContainers[i] = gaugeContainer;
            }


            demoShow4By4.onchange = function (e) {
                demo.classList.toggle('nineByNine', this.checked);
                for (var i = 1; i < rows * cols; i++) {
                    gaugeContainers[i].style.display = (this.checked ? 'inherit' : 'none');
                }
            }

            // fps measurement

            const NUM_SAMPLES = 10.0;
            let now = 0;
            let prev = 0;
            let diff = 0;
            let diffAvg = 0.0;
            let samples = 0;
            let lastChangeMs = 0;
            let stop = true;
            let value = 0;
            let delta = 0.1;

            function synchronizeWithBrowserRepaintCycle(timestamp) {
                if (!stop) {
                    now = performance.now();
                    if (prev !== 0) {
                        diff = parseFloat(now - prev);
                        diffAvg = (samples === 0 ? diff : ((NUM_SAMPLES - 1) * diffAvg + diff) / NUM_SAMPLES);
                        if (samples < NUM_SAMPLES) {
                            samples++;
                        }
                        else {
                            gaugeFpsInp.value = (Math.round(1000.0 / diffAvg));
                        }
                    }

                    if (now - lastChangeMs > 0) {
                        lastChangeMs = now;

                        value = gauges[0].value + delta;
                        if (value >= gauges[0].max) {
                            value = gauges[0].max;
                            delta *= -1;
                        }
                        else if (value <= gauges[0].min) {
                            value = gauges[0].min;
                            delta *= -1;
                        }

                        for (var i = 0; i < rows * cols; i++) {
                            gauges[i].value = value;
                        }
                    }
                    prev = now;

                    window.requestAnimationFrame(synchronizeWithBrowserRepaintCycle);
                }
            }
            function startFpsMeasurement() {
                stop = false;
                diff = 0;
                prev = 0;
                lastChangeMs = now = performance.now();
                synchronizeWithBrowserRepaintCycle();
            }
            function stopFpsMeasurement() {
                stop = true;
            }

            gaugeStartStopToggle.onchange = function (e) {
                if (this.checked && stop) {
                    startFpsMeasurement();
                } else {
                    stopFpsMeasurement();
                }

                this.labels[0].innerHTML = this.checked ? 'Stop' : 'Start';
                this.labels[0].classList.toggle('btn-success', !this.checked);
                this.labels[0].classList.toggle('btn-danger', this.checked);
            }

            // edit, view, recreate (ctrl+s in json editor)

            settingsEditJson.value = JSON.stringify(settings, null, 4);
            settingsViewInitializer.value = VGauge.getObjectInitializer(settings, 4);

            const recreateGaugesFromJson = function () {
                try {
                    for (var i = 0; i < rows * cols; i++) {
                        gauges[i].settings = JSON.parse(settingsEditJson.value);
                        gauges[i].recreate();
                    }

                    settingsViewInitializer.value = VGauge.getObjectInitializer(gauges[0].settings, 4);
                } catch (error) {
                    errorModal._element.querySelector('.modal-body').innerHTML =
                        '<p>vgauge demo: error parsing json\n' + error + '</p>';
                    errorModal.show();
                }
            }

            settingsEditJson.addEventListener("keydown", function (e) {
                if ((e.ctrlKey || e.metaKey) && e.key === "s") {
                    e.preventDefault();
                    recreateGaugesFromJson();
                }
            });

            // output console.error to modal

            console.error = function (message) {
                errorModal._element.querySelector('.modal-body').innerHTML =
                    '<p>vgauge demo : ' + message + '</p>';
                errorModal.show();
            }

            // dark / light theme

            document.querySelector('#darkThemeBtn').onclick = function (e) {
                document.documentElement.setAttribute('data-bs-theme', 'dark');
                for (var i = 0; i < rows * cols; i++) {
                    gauges[i].refresh();
                }
            }
            document.querySelector('#lightThemeBtn').onclick = function (e) {
                document.documentElement.setAttribute('data-bs-theme', 'light');
                for (var i = 0; i < rows * cols; i++) {
                    gauges[i].refresh();
                }
            }


            // target value

            let targetValue = gauges[0].settings.targetValue.min + parseInt((gauges[0].settings.targetValue.max - gauges[0].settings.targetValue.min) / 2);

            for (var i = 0; i < rows * cols; i++) {
                gauges[i].targetValue = targetValue;
            }

            targetValueDecreaseBtn.onclick = function (e) {
                for (var i = 0; i < rows * cols; i++) {
                    gauges[i].targetValue--;
                }
            }
            targetValueIncreaseBtn.onclick = function (e) {
                for (var i = 0; i < rows * cols; i++) {
                    gauges[i].targetValue++;
                }
            }

            // recreate

            gaugeRecreateBtn.onclick = () => {
                recreateGaugesFromJson();
                for (var i = 0; i < rows * cols; i++) {

                    // target value
                    gauges[i].targetValue = targetValue;

                    // fire icon
                    gauges[i].setIconOpacity(1, iconToggle.checked ? 1 : 0);

                    // grid
                    gauges[i].gridOpacity = helperGridToggle.checked ? 1 : 0;
                }
            }


            // helper grid

            helperGridToggle.onclick = function (e) {
                for (var i = 0; i < rows * cols; i++) {
                    gauges[i].gridOpacity = this.checked ? 1 : 0;
                }
            }

            // fire icon
            for (var i = 0; i < rows * cols; i++) {
                gauges[i].setIconOpacity(1, 0.0);
            }

            iconToggle.onclick = function (e) {

                for (var i = 0; i < rows * cols; i++) {
                    if (this.checked) {
                        gauges[i].setIconOpacity(1, 1);
                    }
                    else {
                        gauges[i].setIconOpacity(1, 0);
                    }
                }
            }



            if ('ontouchstart' in document.documentElement) {

                // on touch devices prevent textarea scrolling if no focus
                const textareas = document.querySelectorAll('textarea');
                for (var i = 0; i < textareas.length; i++) {
                    const textarea = textareas[i];
                    textarea.style.overflow = 'hidden';
                    textarea.addEventListener('focus', () => {
                        textarea.style.overflow = 'scroll';
                    });

                    textarea.addEventListener('blur', () => {
                        textarea.style.overflow = 'hidden';
                    });
                }
            }
            else {

                // on others enable bootstrap tooltips (from documentation)
                const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                for (let i = 0; i < tooltipTriggerList.length; i++) {
                    const tooltipTrigger = tooltipTriggerList[i];
                    const tooltip = new bootstrap.Tooltip(tooltipTrigger);
                    tooltipTrigger.addEventListener('click', () => {
                        tooltip.hide(); // hide tooltip if tooltip trigger is clicked
                    });
                }
            }


        });
    </script>

</body>

</html>
