// VGauge 1.0.0, copyright (c) 2024 A.J.Bauer, licensed under the MIT License,see LICENSE.txt for full license text.
class VGauge { static isNonEmptyString(t) { return "string" == typeof t && "" !== t } static isInteger(t) { return Number.isInteger(parseInt(t)) } static isBoolean(t) { return "boolean" == typeof t } static isNonEmptyArray(t) { return Array.isArray(t) && t.length > 0 } static hexRgbForColor(t) { let e, s, i; if (t.startsWith("#")) return 4 === t.length ? (e = t.charAt(1), s = t.charAt(2), i = t.charAt(3), "#" + e + e + s + s + i + i) : t.substring(0, 8); if (t.startsWith("rgb")) { const e = t.match(/\d+/g); return e.length > 2 ? "#" + parseInt(e[0]).toString(16) + parseInt(e[1]).toString(16) + parseInt(e[2]).toString(16) : (console.error(this.constructor.name + ": unexpected value for rgb color"), "#ff0000") } t.length > 0 && console.error(this.constructor.name + ": unsupported color") } static _getObjectInitializer(t, e, s, i) { i = void 0 !== i && i; let r = " ".repeat(s = void 0 === s ? 0 : s) + "{\r\n"; s += e; const n = Object.keys(t).slice(-1)[0]; for (const [i, l] of Object.entries(t)) if (t.hasOwnProperty(i)) if (Array.isArray(l)) { r += " ".repeat(s) + i + ": [\r\n"; for (var a = 0; a < l.length; a++)r += VGauge._getObjectInitializer(l[a], e, s + e, a !== l.length - 1) + "\r\n"; r += " ".repeat(s) + "]" } else r += "object" == typeof l ? " ".repeat(s) + i + ":\r\n" + VGauge._getObjectInitializer(l, e, s, i !== n) + (i !== n ? "\r\n" : "") : "string" == typeof l ? " ".repeat(s) + i + ": '" + l + "'" + (i === n ? "" : ",\r\n") : " ".repeat(s) + i + ": " + l + (i === n ? "" : ",\r\n"); return r += "\r\n" + " ".repeat(s - e) + "}" + (i ? "," : ""), r } static getObjectInitializer(t, e) { return e = void 0 === e ? 1 : e, VGauge._getObjectInitializer(t, e) } constructor(t, e) { this._initialized = !1, this._id = t, this._settings = e, this._value = 0, this._targetValue = 0, this._rootStyles = null, this._bodyStyles = null, this._containerStyles = null, this._container = null, this._svg = null, this._svgElems = { background: null, helperGrid: null, labels: null, name: null, unit: null, value: null, cluster: null, ticks: null, icons: null, valueSector: null, targetValue: null, targetValueIndicator: null }, this._tickLabelsMinusSignWidth = 0, this._tickLabelsHeight = 0, this._targetValueLabelMinusSignWidth = 0, this._targetValueLabelLabelsHeight = 0, this._fontFamily = "", this._currentColor = null, this._width = 0, this._height = 0, this.recreate() } recreate() { if (this._initialized = !1, void 0 !== this._settings && null !== this._settings && "object" == typeof this._settings || console.error(this.constructor.name + ": settings needed"), this._container = document.querySelector("#" + this._id), this._container) { if (this._container.innerHTML = "", this._width = this._height = this._container.clientWidth, this._rootStyles = getComputedStyle(document.documentElement), this._bodyStyles = window.getComputedStyle(document.body), this._containerStyles = window.getComputedStyle(this._container), this._fontFamily = VGauge.isNonEmptyString(this._settings.tweek.fontFamily) ? this._settings.tweek.fontFamily : this._bodyStyles.fontFamily.replace(/"/g, ""), this._currentColor = this._containerStyles.color, this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._svg.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this._svg.setAttribute("viewBox", "-50 -50 100 100"), this._svgElems.background = document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._svgElems.background.setAttribute("x", "-50"), this._svgElems.background.setAttribute("y", "-50"), this._svgElems.background.setAttribute("width", "100"), this._svgElems.background.setAttribute("height", "100"), this._svgElems.background.setAttribute("stroke", "none"), this._svgElems.background.setAttribute("fill", "none"), this._svg.append(this._svgElems.background), VGauge.isBoolean(this._settings.useHelperGrid) && this._settings.useHelperGrid && (this._svgElems.helperGrid = document.createElementNS("http://www.w3.org/2000/svg", "g"), this._svgElems.helperGrid.setAttribute("opacity", "0"), this._svgElems.helperGrid.setAttribute("stroke", "currentColor"), this._svgElems.helperGrid.setAttribute("stroke-width", "0.05"), this._svg.append(this._svgElems.helperGrid)), this._svgElems.labels = document.createElementNS("http://www.w3.org/2000/svg", "g"), this._svgElems.labels.setAttribute("font-family", this._fontFamily), this._svgElems.name = document.createElementNS("http://www.w3.org/2000/svg", "text"), this._svgElems.name.setAttribute("text-anchor", "middle"), this._svgElems.labels.append(this._svgElems.name), this._svgElems.unit = document.createElementNS("http://www.w3.org/2000/svg", "text"), this._svgElems.unit.setAttribute("text-anchor", "start"), this._svgElems.labels.append(this._svgElems.unit), this._svgElems.value = document.createElementNS("http://www.w3.org/2000/svg", "text"), this._svgElems.value.setAttribute("text-anchor", "end"), this._svgElems.value.innerHTML = this._value.toFixed(this._settings.tweek.value.decimals), this._svgElems.labels.append(this._svgElems.value), this._svg.append(this._svgElems.labels), this._settings.cluster) { if (this._svgElems.cluster = document.createElementNS("http://www.w3.org/2000/svg", "g"), VGauge.isNonEmptyArray(this._settings.cluster.sectors)) for (let t = 0; t < this._settings.cluster.sectors.length; t++) { const t = document.createElementNS("http://www.w3.org/2000/svg", "path"); t.setAttribute("d", "M 0,0"), this._svgElems.cluster.append(t) } this._svg.append(this._svgElems.cluster) } if (this._settings.cluster.useTickLabels && (this._svgElems.ticks = document.createElementNS("http://www.w3.org/2000/svg", "g"), this._svg.append(this._svgElems.ticks)), VGauge.isNonEmptyArray(this._settings.icons)) { this._svgElems.icons = document.createElementNS("http://www.w3.org/2000/svg", "g"); for (var t = 0; t < this._settings.icons.length; t++)try { const e = this._settings.icons[t], s = document.createElementNS("http://www.w3.org/2000/svg", "path"), i = "translate(" + e.x + "," + e.y + ") scale(" + e.scale + "," + e.scale + ")"; s.setAttribute("transform", i), s.setAttribute("rid", e.id); const r = (new DOMParser).parseFromString(e.path, "image/svg+xml").querySelector("[d]").getAttribute("d"); s.setAttribute("d", r), s.setAttribute("opacity", e.opacity), VGauge.isNonEmptyString(e.fill) ? s.setAttribute("fill", e.fill) : s.setAttribute("fill", "currentColor"), this._svgElems.icons.append(s) } catch (t) { console.error(this.constructor.name + ": icons error : " + error) } this._svg.append(this._svgElems.icons) } if (this._svgElems.valueSector = document.createElementNS("http://www.w3.org/2000/svg", "path"), this._svg.append(this._svgElems.valueSector), this._settings.targetValue && (this._svgElems.targetValueIndicator = document.createElementNS("http://www.w3.org/2000/svg", "path"), this._svg.append(this._svgElems.targetValueIndicator), this._svgElems.targetValueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"), this._svg.append(this._svgElems.targetValueLabel)), this._container.prepend(this._svg), this._svg.setAttribute("style", "user-select:none"), VGauge.isNonEmptyString(this._settings.tweek.backgroundColor) ? this._svgElems.background.setAttribute("fill", VGauge.hexRgbForColor(this._settings.tweek.backgroundColor)) : this._svgElems.background.setAttribute("fill", "none"), VGauge.isBoolean(this._settings.useHelperGrid) && this._settings.useHelperGrid) { for (let t = -50; t <= 50; t += 10) { const e = document.createElementNS("http://www.w3.org/2000/svg", "line"); e.setAttribute("x1", t), e.setAttribute("x2", t), e.setAttribute("y1", -50), e.setAttribute("y2", 50), 0 === t && e.setAttribute("stroke-width", "0.1"), this._svgElems.helperGrid.append(e) } for (let t = -50; t <= 50; t += 10) { const e = document.createElementNS("http://www.w3.org/2000/svg", "line"); e.setAttribute("x1", -50), e.setAttribute("x2", 50), e.setAttribute("y1", t), e.setAttribute("y2", t), 0 === t && e.setAttribute("stroke-width", "0.1"), this._svgElems.helperGrid.append(e) } } if (this._svgElems.name.setAttribute("x", this._settings.tweek.name.x), this._svgElems.name.setAttribute("y", this._settings.tweek.name.y), VGauge.isNonEmptyString(this._settings.tweek.name.fill) ? this._svgElems.name.setAttribute("fill", this._settings.tweek.name.fill) : this._svgElems.name.setAttribute("fill", "currentColor"), this._svgElems.name.setAttribute("font-size", this._settings.tweek.name.fontSize), this._svgElems.name.innerHTML = this._settings.name, this._svgElems.unit.setAttribute("x", this._settings.tweek.unit.x), this._svgElems.unit.setAttribute("y", this._settings.tweek.unit.y), VGauge.isNonEmptyString(this._settings.tweek.unit.fill) ? this._svgElems.unit.setAttribute("fill", this._settings.tweek.unit.fill) : this._svgElems.unit.setAttribute("fill", "currentColor"), this._svgElems.unit.setAttribute("font-size", this._settings.tweek.unit.fontSize), this._svgElems.unit.innerHTML = this._settings.unit, this._svgElems.value.setAttribute("x", this._settings.tweek.value.x), this._svgElems.value.setAttribute("y", this._settings.tweek.value.y), this._svgElems.value.setAttribute("fill", this._settings.tweek.value.fill), VGauge.isNonEmptyString(this._settings.tweek.value.fill) ? this._svgElems.value.setAttribute("fill", this._settings.tweek.value.fill) : this._svgElems.value.setAttribute("fill", "currentColor"), this._svgElems.value.setAttribute("font-size", this._settings.tweek.value.fontSize), this._settings.cluster && this._settings.cluster.sectors && VGauge.isNonEmptyArray(this._settings.cluster.sectors)) { const t = { x: 0, y: 0 }, e = { x: 0, y: 0 }, s = { x: 0, y: 0 }, i = { x: 0, y: 0 }; let r = this._settings.startAngle * Math.PI / 180, n = this._settings.min, a = 0, l = (t, e) => { const s = { x: 0, y: 0 }, i = e < Math.PI ? e + 1.5 * Math.PI : e + .5 * Math.PI, r = document.createElementNS("http://www.w3.org/2000/svg", "text"); r.innerHTML = t, s.x = this._settings.tweek.ticks.radius * Math.cos(e), s.y = this._settings.tweek.ticks.radius * Math.sin(e); const n = "translate(" + s.x + "," + s.y + ")" + " " + ("rotate(" + 180 * i / Math.PI + ")") + " " + ("translate(" + (t < 0 ? -this._tickLabelsMinusSignWidth / 2 : 0) + "," + this._tickLabelsHeight / 2 + ")"); r.setAttribute("transform", n), this._svgElems.ticks.append(r) }; if (this._settings.cluster.useTickLabels) { const t = new OffscreenCanvas(1, 1).getContext("2d"); t.textAlign = "center", t.textBaseline = "alphabetic", t.font = this._settings.tweek.ticks.fontSize + " " + this._fontFamily, this._tickLabelsMinusSignWidth = t.measureText("-").width, this._tickLabelsHeight = t.measureText("0123456789").actualBoundingBoxAscent, this._settings.targetValue && (t.font = this._settings.targetValue.label.fontSize + " " + this._fontFamily, this._targetValueLabelMinusSignWidth = t.measureText("-").width, this._targetValueLabelHeight = t.measureText("0123456789").actualBoundingBoxAscent), this._svgElems.ticks.setAttribute("text-anchor", "middle"), this._svgElems.ticks.setAttribute("dominant-baseline", "alphabetic"), this._svgElems.ticks.setAttribute("font-size", this._settings.tweek.ticks.fontSize), this._svgElems.ticks.setAttribute("font-family", this._fontFamily), this._svgElems.ticks.setAttribute("opacity", this._settings.tweek.ticks.opacity), VGauge.isNonEmptyString(this._settings.tweek.ticks.fill) ? this._svgElems.ticks.setAttribute("fill", this._settings.tweek.ticks.fill) : this._svgElems.ticks.setAttribute("fill", "currentColor") } for (let h = 0; h < this._settings.cluster.sectors.length; h++) { const g = this._settings.cluster.sectors[h]; s.x = this._settings.cluster.innerRadius * Math.cos(r), s.y = this._settings.cluster.innerRadius * Math.sin(r), i.x = this._settings.cluster.outerRadius * Math.cos(r), i.y = this._settings.cluster.outerRadius * Math.sin(r), a = r + (g.sweepTo - n) * this._settings.sweepAngle / (this._settings.max - this._settings.min) * Math.PI / 180, t.x = this._settings.cluster.innerRadius * Math.cos(a), t.y = this._settings.cluster.innerRadius * Math.sin(a), e.x = this._settings.cluster.outerRadius * Math.cos(a), e.y = this._settings.cluster.outerRadius * Math.sin(a); const u = "M " + s.x + "," + s.y + " A " + this._settings.cluster.innerRadius + " " + this._settings.cluster.innerRadius + " " + 180 * (a - r) / Math.PI + " " + (a - r > Math.PI ? "1" : "0") + " 1 " + t.x + " " + t.y + " L " + e.x + "," + e.y + " A " + this._settings.cluster.outerRadius + " " + this._settings.cluster.outerRadius + " " + 180 * (a - r) / Math.PI + " " + (a - r > Math.PI ? "1" : "0") + " 0 " + i.x + " " + i.y + " L " + s.x + "," + s.y + " Z", o = Array.from(this._svgElems.cluster.querySelectorAll("path"))[h]; o.setAttribute("d", u), o.setAttribute("opacity", g.opacity), VGauge.isNonEmptyString(g.fill) ? o.setAttribute("fill", VGauge.hexRgbForColor(g.fill)) : o.setAttribute("fill", VGauge.hexRgbForColor(this._currentColor)), this._settings.cluster.useTickLabels && (0 === h && l(this._settings.min, this._settings.startAngle * Math.PI / 180), l(g.sweepTo, a)), n = g.sweepTo, r = a } } if (this._settings.targetValue) { if (VGauge.isNonEmptyString(this._settings.targetValue.indicator.path)) { const t = (new DOMParser).parseFromString(this._settings.targetValue.indicator.path, "image/svg+xml").querySelector("[d]").getAttribute("d"); this._svgElems.targetValueIndicator.setAttribute("d", t) } VGauge.isNonEmptyString(this._settings.targetValue.indicator.fill) ? this._svgElems.targetValueIndicator.setAttribute("fill", this._settings.targetValue.indicator.fill) : this._svgElems.targetValueIndicator.setAttribute("fill", "currentColor"), VGauge.isNonEmptyString(this._settings.targetValue.label.fontSize) && this._svgElems.targetValueLabel.setAttribute("font-size", this._settings.targetValue.label.fontSize), VGauge.isNonEmptyString(this._settings.targetValue.label.fill) ? this._svgElems.targetValueLabel.setAttribute("fill", this._settings.targetValue.label.fill) : this._svgElems.targetValueLabel.setAttribute("fill", "currentColor"), this._svgElems.targetValueLabel.setAttribute("text-anchor", "middle"), this._svgElems.targetValueLabel.setAttribute("dominant-baseline", "alphabetic") } this._settings.targetValue && (this.targetValue = this._settings.targetValue.min), this._initialized = !0, this.refresh() } else console.error(this.constructor.name + ": could not find container for id " + this._id) } _update() { const t = this._settings.startAngle * Math.PI / 180; let e = this._settings.startAngle * Math.PI / 180 + (this._value - this._settings.min) * this._settings.sweepAngle / (this._settings.max - this._settings.min) * Math.PI / 180; const s = this._settings.indicator.innerRadius * Math.cos(t), i = this._settings.indicator.innerRadius * Math.sin(t), r = this._settings.indicator.outerRadius * Math.cos(t), n = this._settings.indicator.outerRadius * Math.sin(t), a = this._settings.indicator.innerRadius * Math.cos(e), l = this._settings.indicator.innerRadius * Math.sin(e), h = this._settings.indicator.outerRadius * Math.cos(e), g = this._settings.indicator.outerRadius * Math.sin(e); this._svgElems.value.innerHTML = this._value.toFixed(this._settings.tweek.value.decimals); const u = "M " + s + "," + i + " A " + this._settings.indicator.innerRadius + " " + this._settings.indicator.innerRadius + " " + 180 * (e - t) / Math.PI + " " + (e - t > Math.PI ? "1" : "0") + " 1 " + a + " " + l + " L " + h + "," + g + " A " + this._settings.indicator.outerRadius + " " + this._settings.indicator.outerRadius + " " + 180 * (e - t) / Math.PI + " " + (e - t > Math.PI ? "1" : "0") + " 0 " + r + " " + n + " L " + s + "," + i + " Z"; if (this._settings.cluster && VGauge.isNonEmptyArray(this._settings.cluster.sectors)) { let t = this._settings.cluster.sectors.find((t => t.sweepTo >= this._value)); void 0 === t && (t = this._settings.cluster.sectors[0]), VGauge.isNonEmptyString(t.fill) ? this._svgElems.valueSector.setAttribute("fill", VGauge.hexRgbForColor(t.fill)) : this._svgElems.valueSector.setAttribute("fill", VGauge.hexRgbForColor(this._currentColor)) } else this._svgElems.valueSector.setAttribute("fill", VGauge.hexRgbForColor(this._currentColor)), this._svgElems.valueSector.setAttribute("opacity", 1); if (this._svgElems.valueSector.setAttribute("d", u), this._settings.targetValue) { const t = { x: 0, y: 0 }; e = this._settings.startAngle * Math.PI / 180 + (this._targetValue - this._settings.min) * this._settings.sweepAngle / (this._settings.max - this._settings.min) * Math.PI / 180, t.x = this._settings.targetValue.indicator.radius * Math.cos(e), t.y = this._settings.targetValue.indicator.radius * Math.sin(e); let s = 180 * e / Math.PI - 90, i = "translate(" + t.x + "," + t.y + ") rotate(" + s + ")"; this._svgElems.targetValueIndicator.setAttribute("transform", i); e < Math.PI ? Math.PI : Math.PI; const r = { x: 0, y: 0 }; s = e < Math.PI ? e + 1.5 * Math.PI : e + .5 * Math.PI, r.x = this._settings.targetValue.label.radius * Math.cos(e), r.y = this._settings.targetValue.label.radius * Math.sin(e); i = "translate(" + r.x + "," + r.y + ")" + " " + ("rotate(" + 180 * s / Math.PI + ")") + " " + ("translate(" + (this._targetValue < 0 ? -this._targetValueLabelMinusSignWidth / 2 : 0) + "," + this._targetValueLabelHeight / 2 + ")"), this._svgElems.targetValueLabel.innerHTML = this._targetValue, this._svgElems.targetValueLabel.setAttribute("transform", i) } } refresh() { this._initialized && (this._currentColor = this._containerStyles.color, this._width = this._container.clientWidth, this._height = this._container.clientHeight, this._width > 0 && this._height > 0 && this._update()) } get min() { return this._settings.min } get max() { return this._settings.max } get settings() { return this._settings } set settings(t) { this._settings = t } set value(t) { this._value !== t && (t < this._min ? this._value = this._min : t > this._max ? this._value = this._max : this._value = parseFloat(t), this._initialized && this._update()) } get value() { return this._value } set targetValue(t) { this._settings.targetValue && t !== this._targetValue && (t < this._settings.targetValue.min ? this._targetValue = parseFloat(this._settings.targetValue.min) : t > this._settings.targetValue.max ? this._targetValue = parseFloat(this._settings.targetValue.max) : this._targetValue = parseFloat(t), this._update()) } get targetValue() { return this._targetValue } get gridOpacity() { const t = this._svgElems.helperGrid; return t ? parseFloat(t.getAttribute("opacity")) : 0 } set gridOpacity(t) { const e = this._svgElems.helperGrid; e && e.setAttribute("opacity", t) } setIconOpacity(t, e) { const s = this._container.querySelector('[rid="' + t + '"]'); s && s.setAttribute("opacity", e) } }